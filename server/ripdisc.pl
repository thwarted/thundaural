#!/usr/bin/perl

# $Header: /home/cvs/thundaural/server/ripdisc.pl,v 1.11 2004/01/16 09:36:17 jukebox Exp $

my $bin_getcoverart = './getcoverart.php';
my $bin_cdparanoia = '/usr/bin/cdparanoia';
my $bin_oggenc = '/usr/bin/oggenc';
my $bin_rm = '/bin/rm';
my $bin_fuser = '/sbin/fuser';

use strict;
use warnings;
use DBI;
use CDDB_get qw( get_cddb );

my $storagedir;
my $cddevice;
my $maxtracks = 0;
my $dryrun = 0;
my $sqlitedb = '';
              #0  1   2    3     4      5      6      7       8       9
my @mcscale = (0, 50, 500, 1000, 10000, 25000, 75000, 100000, 200000, 500000);
my $maxcorrections = $mcscale[9];
while (@ARGV) {
	$a = shift @ARGV;
	if ($a =~ m/^--dryrun/) {
		$dryrun = 1;
		next;
	}
	if ($a =~ m/^--maxtracks/) {
		$maxtracks = shift @ARGV;
		$maxtracks += 0;
		die("$0: missing argument to --maxtracks\n") if (!$maxtracks);
		next;
	}
	if ($a =~ m/^--device/) {
		$cddevice = shift @ARGV;
		die("$0: missing argument to --device\n") if (!$cddevice);
		next;
	}
	if ($a =~ m/^--sqlitedb/) {
		$sqlitedb = shift @ARGV;
		die("$0: missing argument to --sqlitedb\n") if (!$sqlitedb);
		die("$0: unable to open sqlitedb $sqlitedb\n") if (!(-e $sqlitedb));
		next;
	}
	if ($a =~ m/^--aggressive/) {
		my $x = shift @ARGV;
		die("$0: missing argument to --aggressive\n") if (!defined($x));
		die("$0: --aggressive argument must be a digit 0 to 9\n") if ($x !~ m/^\d$/);
		$x = int($x);
		$maxcorrections = $mcscale[$x];
		next;
	}
	die("Usage: $0 [--dryrun] [--maxtracks <n>] [--aggressive <0-9>] --device /dev/cdromdevice --sqlitedb <sqlitedb>\n");
}

die ("missing --sqlitedb argument\n") if (!$sqlitedb);

my $devname = $cddevice;
$devname =~ s/\W/_/g;
$devname =~ s/_+/_/g;
my $sqldebugfile = sprintf('/tmp/ripsql.device%s.debug.%d', $devname, $$);

if ($maxcorrections > $mcscale[9] || $maxcorrections < 0) {
	$maxcorrections = $mcscale[9];
}

use Settings;

my %sqlvariables = ();

my $dbh = DBI->connect("dbi:SQLite:dbname=".$sqlitedb,"","");
$dbh->func('setval', 2, sub { my $name = shift; my $value = shift; $sqlvariables{$name} = $value; print "set $name = $value\n"; return $value; }, 'create_function' );

$storagedir = Settings::storagedir();
die("$0: storagedir not set\n") if (!$storagedir);
die("$0: no cd device specified\n") if (!$cddevice);

&cleanup; # delete files generated by previous invocations that might have failed

my $final_sqlcmds = [];
my $finalactions = {};

umask 0002;
my $abort_rip = 0;

&dumpstatus('busy', 'reading CD info');

# get CDDB/FreeDB info for the disc
my %cd;
eval {
	%cd = &cdinfo($cddevice);
};
if (my $x = $@) {
	&dumpstatus('idle', 0);
	die $x;
}
# create new album entry
if (&already_have_album(%cd)) {
	&dumpstatus('idle', sprintf('already have album %s - %s (id %s)', trim($cd{artist}), trim($cd{title}), trim($cd{id})));
} else {
	my $q;

	my $artist = trim($cd{artist});
	my $albumtitle = trim($cd{title});
	my $genre = trim($cd{cat});
	my $cddbid = $cd{id};

	&dumpstatus('busy', 'getting track info', '?', $artist);
	my($tracklens, $albumlength) = &get_track_lengths;
	my $albumkey = &insert_album(\%cd, $albumlength);

	&dumpstatus('busy', 'getting cover art', 0, $artist, $albumtitle, $genre, 0, 0, 0, $cddbid, time(), 0, 0);
	# set up the coverart storage location
	my $p = "$storagedir/coverart";
	mkdir $p, 0777;
	my $sortdir = &get_sort_dir($artist);
	$p .= "/$sortdir";
	mkdir $p, 0777;

	# get the coverart
	my $catemp = &mymktemp.".coverart.jpg";
	my $coverartfile = "coverart/$sortdir/$artist - $albumtitle - $cddbid - coverart.jpg";
	system("$bin_getcoverart \"$artist\" \"$albumtitle\" $catemp 2>/dev/null");

	open(W, ">>$catemp");
	close(W);

	# get id of genre
	my($genreid) = &get_genre($genre);

	my $n;
	my $totaltracks = $#$tracklens + 1;
	$maxtracks = $totaltracks if (!$maxtracks);
	my $startrip = time;

	$SIG{HUP} = sub {
		my $ripchild = &pid_using_device($cddevice);
		kill 15, $ripchild;
		exit;
	};

	for ($n = 0; $n <= ($maxtracks-1); $n++) {
		my $track = $n+1;
		my $tracklength = $tracklens->[$n];
		my $tracktitle = trim($cd{track}->[$n]);
		my $outfile = &mymktemp.".disc$cddbid.track$track.ogg";
		my $sortdir = &get_sort_dir($artist);

		$artist =~ s/\s+\/\s+/--/g;
		$albumtitle =~ s/\s+\/\s+/--/g;
		$tracktitle =~ s/\s+\/\s+/--/g;

		my $realoutfile = "$sortdir/$artist - $albumtitle - $tracktitle.ogg";
		my $tlen = $tracklens->[$n];

		#&log_current_rip("$artist - $albumtitle - $tracktitle (track $track of $maxtracks, $tlen secs in length)", $cddevice);
		my $totalcorrections;
		($abort_rip, $totalcorrections) = &rip_track($track, $outfile, $genre, $artist, $albumtitle, $tracktitle, $maxtracks);
		if ($abort_rip) {
			&dumpstatus('idle', $abort_rip);
			last;
		}

		$q = "insert into tracks (albumid, performer, name, genreid, filename, length, albumorder, riperrors) values (#albumid#, %s, %s, %s, %s, %s, %s, %s)";
		$q = sprintf($q,
				$dbh->quote($artist),
				$dbh->quote($tracktitle),
				$dbh->quote($genreid),
				$dbh->quote($realoutfile),
				$dbh->quote($tracklength),
				$dbh->quote($track),
				$dbh->quote($totalcorrections)
			);
		#push(@$final_sqlcmds, $q);

		$finalactions->{$outfile} = {'finalfile'=>$realoutfile, 'sql'=>$q, 'prefixdir'=>$sortdir};
	}
	my $endrip = time;
	my $riptime = $endrip - $startrip;
	# tricky, get the commands to succeed and just execute SQL, we 
	# special case the non-existance of the source file below
	$q = sprintf('update albums set riptime = %d where albumid = #albumid#', $riptime);
	$finalactions->{&mymktemp} = {'sql'=>$q};

	if (-s $catemp) {
		$q = sprintf("update albums set coverartfile = %s where albumid = #albumid#", $dbh->quote($coverartfile));
		$finalactions->{$catemp} = {'finalfile'=>$coverartfile, 'sql'=>$q, 'prefixdir'=>$sortdir};
	}

	if (!$abort_rip) {
		# run the initial SQL commands
		# (put the album into the database)
		foreach $q (@$final_sqlcmds) {
			if ($dryrun) {
				print "$q\n";
			} else {
				my $sth = &sqlprepare($q);
				eval { $sth->execute; }
			}
		}

		# rename all the files
		my $renamedfiles = 0;
		foreach my $s (keys %$finalactions) {
			my $fa = $finalactions->{$s};

			my $prefix = '';
			$prefix = $fa->{'prefixdir'} if ($fa->{'prefixdir'});
			mkdir "$storagedir/$prefix", 0777;
			if (-d "$storagedir/$prefix") {
				# making the dir was successful or it already existed
				# we'll be able to move the file in
				my $finalfile = '';
				$finalfile = $fa->{'finalfile'} if ($fa->{'finalfile'});
				$finalfile = "$storagedir/$finalfile";
				if ($dryrun) {
					my $q = $fa->{'sql'};
					print "$q\n";
					$renamedfiles++; # so the check below doesn't fail and we end up modifying the database
				} else {
				if ((!-e $s) || rename $s, $finalfile) {
						# renaming the file was successful
						# record it in the database
						my $q = $fa->{'sql'};
						my $sth = &sqlprepare($q);
						eval { $sth->execute; };
						$renamedfiles++;
						# should really have more error checking here
					}
				}
			}
		}
		if (!$renamedfiles) {
			my $sth;
			$sth = &sqlprepare("delete from albums where albumid = #albumid#");
			$sth->execute;
			$sth = &sqlprepare("delete from tracks where albumid = #albumid#");
			$sth->execute;
			&dumpstatus('idle', sprintf('error occured renaming files for %s - %s (id %s)', $artist, $albumtitle, $cddbid));
		} else {
			&dumpstatus('idle', sprintf('successfully ripped album %s - %s (id %s)', $artist, $albumtitle, $cddbid));
		}
	} else {
		&dumpstatus('idle', "rip aborted with error $abort_rip");
	}

	#unlink $file_shellcmds;
	#unlink $file_sqlcmds;
}

sub sqlprepare($) {
	my $q = shift;

	foreach my $k (keys %sqlvariables) {
		my $v = $sqlvariables{$k};
		$k = "#$k#";
		$q =~ s/$k/$v/g;
	}

	if ($sqldebugfile) {
		open(F, ">$sqldebugfile");
		print F "$q\n";
		close(F);
	}
	my $sth = $dbh->prepare($q);
	return $sth;
}

sub get_sort_dir($) {
	my $a = shift;

	$a =~ s/^(An?\W|The\W|\W+)//i;
	$a =~ s/^\s+//;
	($a) = $a =~ m/^(\w)/;
	$a = lc $a;
	return $a;
}

sub cdinfo($) {
	my($cddevice) = @_;
	my %cddbconf;

	$cddbconf{CDDB_HOST}="freedb.freedb.org";  # set cddb host
	$cddbconf{CDDB_PORT}=8880;		 # set cddb port
	$cddbconf{CDDB_MODE}="cddb";	       # set cddb mode: cddb or http
	$cddbconf{CD_DEVICE}=$cddevice;	    # set cd device

	$cddbconf{input} = 0; # no interaction

	my %cd;
	eval {
		%cd = get_cddb(\%cddbconf);
	};

	die "$0: $@" if (!$cd{id});

	return %cd;
}

sub get_genre($) {
	my $genre = shift;
	my ($sth, $q);
	my $genreid = 0;

	$q = "select genreid from genres where genre = ?";
	$sth = $dbh->prepare($q);
	$sth->execute($genre);
	($genreid) = $sth->fetchrow_array;
	$sth->finish;
	return $genreid if ($genreid);

	if ($dryrun) {
		$genreid = -1; # just fill it in, we arn't modifying the database during a dry run
	} else {
		$q = "insert into genres values (NULL, ?)"; # unique index exists on category column
		$sth = $dbh->prepare($q);
		eval {
			$sth->execute($genre);
		};
		$sth->finish;
		$genreid = &last_insert_rowid();
	}

	return $genreid;
}

sub rip_track($$$$$$$) {
	my $track = shift;
	my $outfile = shift;
	my $genre = shift;
	my $artist = shift;
	my $album = shift;
	my $title = shift;
	my $maxtracks = shift;

	my $result = 0;

	# order to process in
	my @opts = ('with error correction', 'without error correction'); 
	# the arguments for cdparanoia to use
	my %opts = ('with error correction'=>'', 'without error correction'=>'--disable-paranoia'); 
	# in the case of disabling paranoia, we won't have any correction attempts and we want to record that
	my %startwithtcvalue = ('with error correction'=>0, 'without error correction'=>'no correction'); 
	my $started = time();
	my $totalcorrections;
	if ($maxcorrections == 0) {
		pop @opts; # no corrections?  just skip trying to do it with corrections
	}
	ATTEMPT:
	foreach my $optsk (@opts) {
		$totalcorrections = $startwithtcvalue{$optsk};
		my $opts = $opts{$optsk};
		$result = 0;
		my $ripcmd = "$bin_cdparanoia $opts --force-cdrom-device $cddevice --stderr-progress --output-wav $track -";
		my $oggcmd = "$bin_oggenc --quiet --genre \"$genre\" --artist \"$artist\" --title \"$title\" --album \"$album\" --output=\"$outfile\" -";

		my $cmd = "($ripcmd | $oggcmd) 2>&1 |";

		if (!open(PAR, $cmd)) {
			$result = "unable to start cdparanoia";
			next ATTEMPT;
		}
		my($fromsec, $tosec, $tracklen);

		my $line;
		CDPSTART:
		while($line = <PAR>) {
			if ($line =~ m/Ripping from sector\s+(\d+)\s/) {
				$fromsec = $1;
				$line = <PAR>;
				($tosec, $tracklen) = $line =~ /to sector\s+(\d+)\s+.+$track\s+\[(.+)\]/;
						     #to sector  150386 (track  6 [4:36.14])
				my @x = split(/\D/, $tracklen);
				$tracklen = ($x[0] * 60) + $x[1] + ($x[2] ? 1 : 0);
				last CDPSTART;
			}
			last if ($line =~ m/^##/);
		}

		if (!defined($fromsec) || !defined($tosec)) {
			close(PAR);
			$result = "unable to start cdparanoia";
			next ATTEMPT;
		}
		my $range = $tosec - $fromsec;

		my $oldpct = sprintf('%.2f', 0);
		my $corrections = 0;

		my $FRAMESIZE = 2352 / 2;

		my $mod = int(rand(15)) + 43;

		my $cdpid;
		CDPOUTPUT:
		while($line = <PAR>) {
			if (!$cdpid) {
				$cdpid = &pid_using_device($cddevice);
			}
			if (!(kill 0, $cdpid)) {
				last CDPOUTPUT;
			}
			if ($line =~ m/\[correction\] \@ (\d+)/) {
				my $sector = ((1 + $1) / $FRAMESIZE) - 1;
				$corrections++;
				$totalcorrections++ if ($optsk ne 'without error correction');
				if (($corrections % $mod) == 0) {
					&dumpstatus('ripping', $optsk, "$track/$maxtracks", $artist, $title, $genre, 0, &calc_speed($tracklen, $started, $oldpct), $tracklen, '?', $started, $corrections, $oldpct);
				}
				if ($corrections >= $maxcorrections) {
					&dumpstatus('ripping', $optsk, "$track/$maxtracks", $artist, $title, $genre, 0, &calc_speed($tracklen, $started, $oldpct), $tracklen, '?', $started, $corrections, $oldpct);
					kill 15, $cdpid;
					close(PAR);
					next ATTEMPT;
				}
				next CDPOUTPUT;
			}
			if ($line =~ m/\[wrote\] \@ (\d+)/) {
				my $sector = ((1 + $1) / $FRAMESIZE) - 1;
				my $pct = sprintf('%.2f', 100 *($sector-$fromsec)/$range);
				if ($pct ne $oldpct) {
					$corrections = 0;
					$oldpct = $pct;
					&dumpstatus('ripping', $optsk, "$track/$maxtracks", $artist, $title, $genre, 0, &calc_speed($tracklen, $started, $oldpct), $tracklen, '?', $started, $corrections, $oldpct);
				}
				next CDPOUTPUT;
			}
		}
		close(PAR);

		my $exit_value  = $? >> 8;
		my $signal_num  = $? & 127;
		my $dumped_core = $? & 128;

		my @ret = ();
		push(@ret, "signal $signal_num)") if $signal_num;
		push(@ret, "dumped core") if ($dumped_core);
		push(@ret, "exit value $exit_value") if ($exit_value);
		if (@ret) {
			$result = join(', ', @ret); # FAILURE
		}
		last ATTEMPT; # if we get this far, it most likely succeeded
		# multiple times through this loop would happen when corrections goes over the limit
	}
	if (!-s $outfile) {
		$result = "output file empty";
	}
	return ($result, $totalcorrections); # SUCCESS!
}

sub last_insert_rowid() {
	my $q = "select last_insert_rowid()";
	my $sth = $dbh->prepare($q);
	$sth->execute;
	my ($c) = $sth->fetchrow_array;
	$sth->finish;
	return $c;
}

sub already_have_album(%) {
	my(%cd) = @_;
	my($q, $sth);

	$q = "select albumid from albums where cddbid = ?";
	$sth = $dbh->prepare($q);
	$sth->execute($cd{id});
	my($albumid) = $sth->fetchrow_array;
	$sth->finish;
	return $albumid;
}

sub insert_album(%) {
	my $cd = shift;
	my $albumlen = shift;

	my %cd = %$cd;
	my($q, $sth);
	$q = "insert into albums (performer, name, cddbid, tracks, length) values (%s, %s, %s, %s, %s)";
	$q = sprintf($q, 
			$dbh->quote(&trim($cd{artist})),
			$dbh->quote(&trim($cd{title})),
			$dbh->quote(&trim($cd{id})),
			$dbh->quote(&trim($cd{tno})),
			$dbh->quote(&trim($albumlen))
		);
	push(@$final_sqlcmds, $q);
	$q = "select setval('albumid', last_insert_rowid())";
	push(@$final_sqlcmds, $q);
}

sub mymktemp { return sprintf('%s/riptemp.device%s.pid%d.rand%d', $storagedir, $devname, $$, int(rand(99999))); }
sub trim { my($s) = shift; $s = '' if (!defined($s)); $s =~ s/\s+/ /g; $s =~ s/^\s+//; $s =~ s/\s+$//; $s =~ s/"//g; return $s; }

sub get_track_lengths {
	my $tmpfile = &mymktemp;
	my $albumlength;
	my $x = sprintf("%s --query 2> %s", $bin_cdparanoia, $tmpfile);
	system($x);
	open(T, "<$tmpfile");
	while($_ = <T>) {
		last if (m/Table of contents.*:/);
	}
	my $res = [];
	# [.30] would be thirty sectors (75 sectors per second).
	while($_ = <T>) {
		s/^\s+//;
		next if (!m/^\d+\./ && !m/^TOTAL/);
		my($trackno, $sectors, $lentime) = split(/\s+/);
		$lentime = (sprintf("%.0f", $sectors / 75))+1; # 75 sectors per second, round up
		if ($trackno =~ m/TOTAL/) {
			$albumlength = $lentime;
		} else {
			push(@$res, $lentime);
		}
	}
	#($lentime) = $lentime =~ m/\[(\d+:\d+\.\d+)\]/;
	#TOTAL  213302 [47:24.02]

	close(T);
	return ($res, $albumlength);
}

sub calc_speed($$) {
	my($length, $started, $pct) = @_;
	$pct /= 100;
	my $now = time();
	my $x1 = $now - $started;
	my $xc = $length * $pct;
	my $speed;
	eval { $speed = $xc / $x1; };
	$speed = 0 if ($@);
	$speed = sprintf("%.2f", $speed);
	return $speed;
}

sub dumpstatus($$$$$$$$$$$) {
	my($state, $volume, $trackref, $performer, $name, $genre, $popularity, $rank, $length, $trackid, $started, $current, $percentage) = @_;
	push(@_, '', '', '', '', '', '', '', '', '', '', '', '', '');
	my @x = @_[0..12];
	print $cddevice."\t".join("\t", @x)."\n";
	#print "$cddevice\t$state\t$volume\t$tracknum\t$artist\t$trackname\t$pct\t$corrections\n";
}

sub log_current_rip($$) {
	my $currentrip = shift;
	my $device = shift;
	my $name = shift || 'trackripping';
	my($p, $f, $l) = caller;
	print "log_current_rip called at $f:$l\n";
	#print "$name\t$device\t$currentrip\n";
	return;
#	if (defined($currentrip)) {
#		&log_current_rip(undef, $device);
#		my $q = "insert into status (name, devicename, value) values (?, ?, ?)";
#		my $sth = $dbh->prepare($q);
#		eval {
#			$sth->execute($name, $device, $currentrip);
#		};
#	} else {
#		my $q = "delete from status where name = ?";
#		if ($device) {
#			$q .= " and devicename = ?";
#		}
#		my $sth = $dbh->prepare($q);
#		eval {
#			if ($device) {
#				$sth->execute($name, $device);
#			} else {
#				$sth->execute($name);
#			}
#		};
#	}
}

sub cleanup {
	&dumpstatus("cleanup", '', '', '', '', '', '', '');
	my $pattern = sprintf('%s/riptemp.device%s.*', $storagedir, $devname);
	`$bin_rm -f $pattern`;
	sleep 3;
}

sub pid_using_device($) {
	my $d = shift;

	my @x = `$bin_fuser $d`;
	if (@x) {
		my $x = shift @x;
		my(undef, $p) = split(/\s+/, $x);
		return ($p+0) if ($p =~ m/^\d+f?$/);
	}
	return undef;
}

__END__

Table of contents (audio tracks only):
track	length	       begin	copy pre ch
===========================================================
  1.    19547 [04:20.47]       33 [00:00.33]    no   no  2
  2.    13725 [03:03.00]    19580 [04:21.05]    no   no  2
  3.    15545 [03:27.20]    33305 [07:24.05]    no   no  2
  4.    15503 [03:26.53]    48850 [10:51.25]    no   no  2
  5.    12837 [02:51.12]    64353 [14:18.03]    no   no  2
  6.    35038 [07:47.13]    77190 [17:09.15]    no   no  2
  7.    13917 [03:05.42]   112228 [24:56.28]    no   no  2
  8.    12415 [02:45.40]   126145 [28:01.70]    no   no  2
  9.    18180 [04:02.30]   138560 [30:47.35]    no   no  2
 10.    10973 [02:26.23]   156740 [34:49.65]    no   no  2
 11.     4972 [01:06.22]   167713 [37:16.13]    no   no  2
 12.     5455 [01:12.55]   172685 [38:22.35]    no   no  2
 13.     8830 [01:57.55]   178140 [39:35.15]    no   no  2
 14.     6868 [01:31.43]   186970 [41:32.70]    no   no  2
 15.     7265 [01:36.65]   193838 [43:04.38]    no   no  2
 16.    10487 [02:19.62]   201103 [44:41.28]    no   no  2
 17.     1745 [00:23.20]   211590 [47:01.15]    no   no  2
TOTAL  213302 [47:24.02]    (audio only)


