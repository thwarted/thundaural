#!/usr/bin/perl

# $Header: /home/cvs/thundaural/checkdeps,v 1.9 2004/03/27 18:12:24 jukebox Exp $

# just a little quick and dirty script to help you make sure you have all the 
# dependancies installed.  It should really be better than this.  lots of code 
# duplication here

# and it should really generate settings/config files for the optional portions

use Data::Dumper;

$| = 1;

my $check_client = 0;
my $check_server = 0;
my $softfail = 0;

my $prfailed = 0;

while(@ARGV) {
	my $a = shift (@ARGV);
	if ($a =~ m/^--client/) {
		$check_client = 1;
		next;
	}
	if ($a =~ m/^--server/) {
		$check_server = 1;
		next;
	}
	if ($a =~ m/^--softfail/) {
		$softfail = 1;
		next;
	}
	die("$0: unknown option $a\nUsage: $0 [--client] [--server] [--softfail]\n");
}

if (!$check_client && !$check_server) {
	$check_client = 1;
	$check_server = 1;
}

sub mydie {
	my $msg = shift;
	if ($msg) {
		$msg .= "\n" if ($msg !~ m/\n$/);
		if ($softfail) {
			warn("\n*** $msg");
			$prfailed = 1;
		} else {
			die("\n*** $msg");
		}
	} else {
		print " ok\n";
	}
}

use Config;

if ($check_server) {
	print "\nChecking dependancies for server...\n";
	&checking("threaded perl");
	$Config{useithreads} or &mydie("this program requires a threaded perl (ithreads)\n");
	&ok;

	my @modules = qw/DBI DBD::SQLite File::Basename Socket IO::Socket
	IO::Socket::INET IO::Select IPC::Open2 threads threads::shared
	Thread::Queue LWP LWP::UserAgent XML::Ximple Data::Dumper
	CDDB_get
	/;

	foreach my $mod (@modules) {
		&checking('perl module', $mod);
		&havemodule($mod) or &mydie("unable to locate module $mod");
		&ok;
	}

	my %dirs = (
		'/home/storage' => 'general storage directory',
		'/home/storage/db' => 'storage for SQLite database',
	);

	foreach my $dir (keys %dirs) {
		&checking("", $dirs{$dir});
		(-d $dir) || &mydie("unable to find directory $dir\n");
		&ok;

		&checking("accessiblity of", sprintf("%s (%s)", $dirs{$dir}, $dir));
		my $x = `cd $dir > /dev/null 2>/dev/null ; echo \$?`;
		$x += 0;
		&mydie("unable to cd to $dir") if ($x);
		open(X, ">$dir/thundauralxxx.$$.tmp") || &mydie("unable to write to $dir");
		close(X);
		unlink("$dir/thundauralxxx.$$.tmp");
		opendir(X, $dir) || &mydie("unable to open $dir for reading\n");
		readdir(X) || &mydie("unable to get directory listing of $dir\n");
		closedir(X);
		&ok;
	}

	my $server_found_progs = {};

	my @programs = (
		{ 'for'=>'ripping audio', 'type'=>'oneof', 'list'=>['dagrab', 'cdda2wav', 'cdparanoia'] },
		{ 'for'=>'audio info extracting', 'type'=>'must', 'list'=>'cdda2wav' },
		# --version doesn't work for cdda2wav version 1, but --help does work on both
		{ 'for'=>'cdda2wav version', 'type'=>'grep', 'pattern'=>'^Version 2', 'list'=>'cdda2wav --help 2>&1' },
		{ 'for'=>'changing the volume', 'label'=>'aumix', 'type'=>'oneof', 'list'=>['aumix-minimal', 'aumix'] },
		{ 'for'=>'encoding audio', 'type'=>'must', 'list'=>'oggenc' },
		{ 'for'=>'playing audio', 'type'=>'must', 'list'=>'ogg123' },
		# no offical support yet
		#{ 'for'=>'playing audio', 'type'=>'optional', 'list'=>'mpg123' },
		#{ 'for'=>'playing audio', 'type'=>'optional', 'list'=>'mpg321' },
		{ 'for'=>'determining device usage', 'type'=>'must', 'list'=>'fuser' },
		{ 'for'=>'removing files', 'type'=>'must', 'list'=>'rm' },
		{ 'for'=>'downloading cover art', 'type'=>'must', 'list'=>'php' },
	);

	NEXTPROG:
	foreach my $prog (@programs) {
		my $for = $prog->{'for'};
		my $type = $prog->{'type'};
		my $label = $prog->{'label'};
		if ($type eq 'oneof') {
			my $list = $prog->{'list'};
			foreach my $p (@{$list}) {
				&checking('program', $p);
				if (my $where = &haveprogram($p)) {
					&ok($where);
					$server_found_progs->{$label} = $where
						if (defined($label) && $label);
					next NEXTPROG;
				} else {
					print " unable to find $p\n";
				}
			}
			&mydie("unable to locate one of ".join(', ', @{$list})." (used for $for) in path\n");
		} elsif ($type eq 'grep') {
			&checking('', $prog->{'for'});
			my $pat = $prog->{'pattern'};
			my $prog = $prog->{'list'};
			my $cdda2wavpath = $server_found_progs->{'cdda2wav'};
			$prog =~ s/cdda2wav/$cdda2wavpath/g;
			my @x = `$prog`;
			my @y = grep(/$pat/, @x);
			if (@y) {
				my $msg = shift @y;
				chomp $msg;
				&ok($msg);
			} else {
				&mydie("it doesn't look like cdda2wav is version 2\n");
			}
			next NEXTPROG;
		} elsif ($type eq 'must') {
			my $for = $prog->{'for'};
			my $prog = $prog->{'list'};
			&checking("program used for $for", $prog);
			my $where;
			($where = &haveprogram($prog)) or &mydie("unable to locate $prog (used for $for) in path\n");
			$server_found_progs->{$prog} = $where;
			&ok($where);
		} elsif ($type eq 'optional') {
			my $for = $prog->{'for'};
			my $prog = $prog->{'list'};
			&checking("program used for $for", $prog);
			my $where;
			if ($where = &haveprogram($prog)) {
				$server_found_progs->{$prog} = $where;
				&ok($where);
			} else {
				warn("unable to locate $prog (used for $for) in path\n");
			}
		} else {
			die("unknown program type \"$type\"");
		}
	}

	my @files = qw!
		/usr/local/lib/php/AmazonSearch.php
		/usr/local/lib/php/class.nusoap_base.php
		/usr/local/lib/php/class.soapclient.php
		/usr/local/lib/php/class.soap_fault.php
		/usr/local/lib/php/class.soap_parser.php
		/usr/local/lib/php/class.soap_server.php
		/usr/local/lib/php/class.soap_transport_http.php
		/usr/local/lib/php/class.soap_val.php
		/usr/local/lib/php/class.wsdl.php
		/usr/local/lib/php/class.xmlschema.php
		/usr/local/lib/php/nusoap.php
	!;
	foreach my $f (@files) {
		&checking('php lib file', $f);
		if (!-s $f) {
			mydie("please copy the contents of server/usr-local-lib-php to /usr/local/lib/php");
			last;
		}
		&ok;
	}

	&runogg123check();

	open(T, ">TAProgramLocations.pm") || die("unable to open TAProgramLocations.pm for writing\n");
	print T "package TAProgramLocations;\n";
	print T "# this file is automaticly generated by checkdeps\n\n";
	foreach my $p (keys %{$server_found_progs}) {
		my $px = $p;
		$px =~ s/\W/_/g;
		printf T 'sub %s { \'%s\'; }', $px, $server_found_progs->{$p};
		print T "\n";
	}
	print T "\n1;\n";
	close(T);

	print "*********************\n";
	print "Be sure to move the generated file, TAProgramLocations.pm, into the server directory.\n";
	print "*********************\n";
}


if ($check_client) {
	print "\nChecking dependancies for client...\n";

	# I ripped this code out of Makefile.linux in the SDL_perl distribution
	my @dirs=(
		'/usr/local/include/SDL',
		'/usr/local/include',
		'/usr/include/SDL',
		'/usr/include',
	);

	# stupid little hack to get them to be checked in the order I designate
	my %ext = (
		# all my gfx come in PNG format
		x1_png=>{inc=>'HAVE_PNG', test=>'png.h', srcpage=>'http://www.rpmfind.net/linux/rpm2html/search.php?query=libpng'},
		# for good measure (coverart is usually in jpeg format)
		x2_jpeg=>{inc=>'HAVE_JPEG',test=>'jpeglib.h',srcpage=>'http://www.rpmfind.net/linux/rpm2html/search.php?query=libjpeg'}, 
		x3_SDL=>{ inc =>'HAVE_SDL', test=>'SDL.h',srcpage=>'http://www.libsdl.org/download-1.2.php'},
		x4_SDL_image=>{inc=>'HAVE_SDL_IMAGE', test=>'SDL_image.h', srcpage=>'http://www.libsdl.org/projects/SDL_image/'},
		x4_SDL_ttf=>{inc=>'HAVE_SDL_TTF',test=>'SDL_ttf.h',srcpage=>'http://www.libsdl.org/projects/SDL_ttf/'},
		x4_SDL_gfx=>{inc=>'HAVE_SDL_GFX',test=>'SDL_gfxPrimitives.h',srcpage=>'http://www.ferzkopp.net/~aschiffler/Software/SDL_gfx-2.0/'},
	);      

	for my $e ( sort keys %ext ) {
		for my $d (@dirs) {
	        	$ext{$e}{exists} ||= -e "$d/$ext{$e}{test}"
		}
	}

	foreach my $e ( sort keys %ext ) {
		my $pe = $e; $pe =~ s/^x\d+_//;
		&checking('headers for library', $pe);
		if (!$ext{$e}->{'exists'}) {
			&mydie("Unable to locate $pe libraries.  You can obtain source from ".$ext{$e}->{'srcpage'});
		}
		&ok;
	}

	&checking('perl module', 'SDL');
	&havemodule('SDL') or &mydie("Unable to locate module SDL.  Grab the necessary version 2.0.2 from the Thundaural website download section.");
	&ok;

	&checking('SDL perl version');
	eval "use SDL;";
	&mydie("Unable to locate SDL Perl.  Grab the necessary version 2.0.2 from the thundaural website download section.") if ($@ =~ m/^Can't locate/);
	&mydie("SDL Perl version must be 2.0.2.  Grab it from the thundaural website download section.") unless ($SDL::VERSION =~ /^2\.\d+\.\d+$/);
	&ok($SDL::VERSION);

	&checking('SDL perl supports event push');
	eval 'use SDL::Event; my $e = new SDL::Event; $e->push();';
	&mydie("Version of SDL Perl doesn't define SDL::Event::push.  Use version 2.1.0 from the thundaural download section.") if ($@ =~ m/Can't locate object method "push/);
	&ok("SDL::Event::push found");

	@modules = qw/SDL::Surface SDL::Constants 
	SDL::App SDL::Event SDL::Color SDL::Timer SDL::Font 
	SDL::TTFont SDL::Tool::Graphic SDL::Cursor IO::Socket IO::Socket::INET/;

	foreach my $mod (@modules) {
		&checking('perl module', $mod);
		&havemodule($mod) or &mydie("unable to locate module $mod");
		&ok;
	}

	my @programs = qw/ xscreensaver-command /;

	foreach my $prog (@programs) {
		&checking('program', $prog);
		&haveprogram($prog) or &mydie("unable to locate $prog");
		&ok;
	}
}


sub runogg123check {
	# god damn, it is super complex to check for this
	# if anyone has a better idea, let me know

	my $SCRTMP = "/tmp/testogg123.$$.sh";
	
	&checking('ogg123');

	open(X, ">$SCRTMP");
	print X <<'EOF';
#!/bin/bash

TMPF=/tmp/testogg123.$$.out
touch $TMPF
if [ ! -f $TMPF ]; then
	exit 8
fi
/usr/bin/ogg123 --remote - </dev/null >$TMPF 2>&1 &
CHP=$!
/bin/kill -9 $CHP
RET=0
grep -F 'unrecognized option' $TMPF >/dev/null 2>/dev/null
if [ $? == 0 ]; then
	# ogg123 doesn't support --remote
	RET=1
else
	grep -F '@E Unknown command' $TMPF >/dev/null 2>/dev/null
	if [ $? == 0 ]; then
	        # ogg123's remote patch isn't patched to fix stdin close
	        RET=2
	fi
fi
if [ -f $TMPF ]; then
	rm -f $TMPF
fi
#echo "ret = $RET"
exit $RET # it is patched!

EOF

	close(X);
	system("/bin/bash $SCRTMP >/dev/null 2>/dev/null");
	my $ret = $?;
	$ret = $ret >> 8;
	unlink($SCRTMP) if ( -f $SCRTMP);

	my $url = 'http://thwartedefforts.org/jukebox/downloads.php';
	my $msg;
	if ($ret == 1) {
		&mydie("ogg123 doesn't support --remote (see $url)");
	} elsif ($ret == 2) {
		&mydie("ogg123's --remote support isn't patched to handle stdin close (see $url)");
	} elsif ($ret == 0) {
		&ok("ogg123 is patched for --remote");
	} else {
		&mydie("an error occured while checking ogg123");
	}
}

####

sub haveprogram {
	my $prog = shift;
	open(X, "which $prog 2>/dev/null |");
	my $where = <X>;
	close(X);
	my $r = $? >> 8;
	chomp $where;
	return $r == 1 ? 0 : $where;
}


sub havemodule {
	my $mod = shift;
	eval "require($mod);";
	return $@ =~ m/^Can't locate/ ? 0 : 1;
}

sub checking {
	my $what = pop;
	my $type = shift;
	$type .= " " if ($type);
	print "  checking for $type$what...";
	$prfailed = 0;
}

sub ok {
	return if ($prfailed);
	if (@_) {
		my $msg = shift;
		print " $msg\n";
	} else {
		print " ok\n";
	}
}

